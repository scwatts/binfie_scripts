# NCBI taxonomy reference
The maintainers of taxonomy database from NCBI regularly dump the database to text files which can be accessed from the NCBI
FTP. The database dump is particularly useful when wanting to relate one taxonomic rank to another. This document will show
how to download database dump, describe useful files, and demonstrate how to iterate the taxonomic tree.

## Downloading
The latest dump of the database can be accessed such as:
```bash
mkdir -p data/
wget -P data/ ftp://ftp.ncbi.nih.gov/pub/taxonomy/taxdump.tar.gz
tar -zxvf data/taxdump.tar.gz -C data/
```

There are also historical dumps which have been archived. They can be found in:
```bash
ftp://ftp.ncbi.nih.gov/pub/taxonomy/taxdump_archive/
```

## Contents
Below I have summarised information relevant to my usages and more detailed information for the taxonomy database dump can be
found in this README:
```bash
curl -s ftp://ftp.ncbi.nih.gov/pub/taxonomy/taxdump_readme.txt | less
```

### nodes.dmp
The nodes file contains a tree of taxonomy data. The following fields are typically of most use:

| column    | name              | description                   |
| ---       | ---               | ---                           |
| 1         | tax_id            | node id                       |
| 2         | parent tax_id     | parent node id                |
| 3         | rank              | taxonomic rank of this node   |

### names.dmp
This file contains name information for each taxonomic rank and simply uses `node id` key to map related data.

| column    | name          | description           |
| ---       | ---           | ---                   |
| 1         | tax_id        | node id               |
| 2         | name_txt      | name                  |
| 3         | unique name   | unique name variant   |
| 4         | name class    | name type             |

Often the desired entries are those that have a `name class` of `scientific name`.

## How to use
### Traversing the tree
One common task is to traverse the taxonomic tree and extract name information at certain nodes. Here are a set of examples
to read and traverse the data:
```python
class Node:

    def __init__(self, nid, pid, rank):
        self.nid = nid
        self.pid = pid
        self.rank = rank


def read_nodes(nodes_fp):
    nodes = dict()
    with nodes_fp.open('r') as fh:
        line_token_gen = (line.rstrip().split('\t|\t') for line in fh)
        for line_tokens in line_token_gen:
            node = Node(*line_tokens[:3])
            nodes[node.nid] = node
    return nodes


def read_names(names_fp):
    names = dict()
    with names_fp.open('r') as fh:
        line_token_gen = (line.rstrip('\t|\n').split('\t|\t') for line in fh)
        for node_id, node_name, node_uname, node_type in line_token_gen:
            if node_type != 'scientific name':
              continue
            assert node_id not in names
            names[node_id] = node_name
    return names


def traverse_to_genus(taxid, nodes):
    pid = taxid
    cid = None
    while pid != cid:
        node = nodes[pid]
        cid, pid, rank = node.nid, node.pid, node.rank
        if rank == 'genus':
            return cid
    return None


def complete_example(names_fp, nodes_fp, taxid_input):
    # Read in data
    names = read_names(names_fp)
    nodes = read_nodes(nodes_fp)
    # Traverse until we reach rank of genus or root
    taxid_result = traverse_to_genus(taxid_input, nodes)
    # Print associated info
    name_input = names[taxid_input]
    if taxid_result:
        message = 'Input taxid %s (%s) has a genus node taxid of %s (%s)'
        name_result = names[taxid_result]
        print(message % (taxid_input, name_input, taxid_result, name_result))
    else:
        print('Could not find genus level node for %s (%s)' % (taxid_input, name_input))

```

### Species summarisation
The above approach is effective in find the species node for a given node. However if performance is a primarily concern,
then use of `categories.dmp` from the `taxcat.tar.gz` dump is recommended. This file contains all ranks below species with
mappings to the species node - such information enables species identification by a single set check and then a dictionary
lookup.

### Other thoughts
Preprocessing the taxonomic tree to determine which nodes are above a desired rank could also greatly improve performance
(depending on query size of course). Here is an example script I've used to do this:
```python
#!/usr/bin/env python3
import argparse
import pathlib


'''NOTE: in the 12/06/2016 centrifuge database p+h+v release, the taxonomy tree generated by
centrifuge-inspect does not include nodes 1921421 and 1916956 despite these taxa being present in
the database. Both nodes are at the species level and represent Synechococcus sp. SynAce01 and
Bacillus sp. JF8 respectively. To mitigate issues where reads are classified to either of these
nodes, we manually add the nodes to the names and node data structure.'''


MISSING_NODES = {'1916956': 'Synechococcus sp. SynAce01',
                 '1921421': 'Bacillus sp. JF8'}


class Node:

    def __init__(self, nid, pid, rank):
        self.nid = nid
        self.pid = pid
        self.rank = rank


def get_arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument('--nodes_fp', required=True, type=pathlib.Path,
            help='nodes filepath (generated by centrifuge-inspect --taxonomy-tree)')

    args = parser.parse_args()
    if not args.nodes_fp.exists():
        parser.error('Input file %s does not exist' % args.nodes_fp)
    return args


def main():
    # Get commandline arguments
    args = get_arguments()

    # Parse nodes file
    nodes = dict()
    with args.nodes_fp.open('r') as fh:
        line_token_gen = (line.rstrip().split('\t|\t') for line in fh)
        for line_tokens in line_token_gen:
            node = Node(*line_tokens)
            nodes[node.nid] = node

    # TEMP (HOPEFULLY): add missing taxonomy data
    for node_id, node_name in MISSING_NODES.items():
        nodes[node_id] = Node(node_id, None, 'species')

    # Find nodes which are below species
    print('node', 'species_node', sep='\t')
    for node in nodes:
        species_node = find_species_rank(node, nodes)
        if not species_node:
            continue
        print(node, species_node, sep='\t')


def find_species_rank(tid, nodes):
    pid = tid
    cid = None
    while pid != cid:
        node = nodes[pid]
        cid, pid, rank = node.nid, node.pid, node.rank
        if rank == 'species':
            return cid
    return None


if __name__ == '__main__':
    main()
```
